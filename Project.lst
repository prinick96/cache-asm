Microsoft (R) Macro Assembler Version 12.00.31101.0	    01/27/17 16:49:24
main.asm						     Page 1 - 1


				; ----------------------------
				; Simulador de movimiento de bloques y particionamiento en memoria caché.
				; Narváez Brayan - 24905388
				; Viernes 27-01-2017
				; ASSEMBLYx86 MASM32 + IRVINE32 (I/O)
				; ----------------------------
				.386
				INCLUDE Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 
 = 00000050			BufSize = 80

				; ----------------------------
				; Sección de declaración
				; ----------------------------
 00000000			.data
					; ----------------------------
					; Variables de uso global
					; ----------------------------
 00000000 20 0D 0A 00			$br_str BYTE " ",0dh,0ah,0 
 00000004 53 49 4D 55 4C		$menuStr BYTE "SIMULADOR DE CACHE",
	   41 44 4F 52 20
	   44 45 20 43 41
	   43 48 45 0D 0A
	   0D 0A 31 2D 20
	   50 61 72 74 69
	   63 69 6F 6E 61
	   6D 69 65 6E 74
	   6F 20 64 65 20
	   62 69 74 73 20
	   64 65 20 64 69
	   72 65 63 63 69
	   6F 6E 65 73 0D
	   0A 32 2D 20 52
	   65 65 6D 70 6C
	   61 7A 6F 20 64
	   65 20 42 6C 6F
	   71 75 65 73 0D
	   0A 33 2D 20 53
	   61 6C 69 72 0D
	   0A 4F 70 63 69
	   6F 6E 3A 20 00
					0dh, 0ah, 0dh, 0ah,
					"1- Particionamiento de bits de direcciones", 0dh, 0ah,
					"2- Reemplazo de Bloques", 0dh, 0ah,
					"3- Salir", 0dh, 0ah,
					"Opcion: ", 0
 00000072 43 6F 6E 74 69		$menuRegreso BYTE "Continuar en el programa? 1(Si) / 2(No): ", 0
	   6E 75 61 72 20
	   65 6E 20 65 6C
	   20 70 72 6F 67
	   72 61 6D 61 3F
	   20 31 28 53 69
	   29 20 2F 20 32
	   28 4E 6F 29 3A
	   20 00
 0000009C 54 41 47 3A 20		$sTAG BYTE "TAG: ", 0
	   00
 000000A2 53 49 43 3A 20		$sSIC BYTE "SIC: ", 0
	   00
 000000A8 42 49 43 3A 20		$sBIC BYTE "BIC: ", 0
	   00
 000000AE 57 49 42 3A 20		$sWIB BYTE "WIB: ", 0
	   00
 000000B4 45 6C 20 62 6C		$sMod1Fin1_ BYTE "El bloque se coloca en la linea ", 0
	   6F 71 75 65 20
	   73 65 20 63 6F
	   6C 6F 63 61 20
	   65 6E 20 6C 61
	   20 6C 69 6E 65
	   61 20 00
 000000D5 45 6C 20 62 6C		$sMod1Fin1 BYTE "El bloque se coloca en el conjunto ", 0
	   6F 71 75 65 20
	   73 65 20 63 6F
	   6C 6F 63 61 20
	   65 6E 20 65 6C
	   20 63 6F 6E 6A
	   75 6E 74 6F 20
	   00
 000000F9 20 64 65 20 6C		$sMod1Fin2 BYTE " de la memoria cache.",0
	   61 20 6D 65 6D
	   6F 72 69 61 20
	   63 61 63 68 65
	   2E 00

 0000010F 00000400			$n1024 DWORD 1024
 00000113  00000007 [			$config DWORD 7 DUP(0)
	    00000000
	   ]
 0000012F 00				$contador BYTE ?
 00000130 00000000			$divcounter DWORD ?
 00000134 00000000			$mod2counter DWORD 0
 00000138 00000000			$DWnumero DWORD ?
 0000013C  00000200 [			$BloqueCache BYTE 512 DUP('0')
	    30
	   ]
 0000033C 00000000			$BloqueCacheLongitud DWORD 0
 00000340  00000200 [			$binario BYTE 512 DUP('0')
	    30
	   ]
 00000540  000000C8 [			$binarioSICBIC BYTE 200 DUP('0')
	    30
	   ]
 00000608 00000000			$binarioSICBICLongitud DWORD 0
 0000060C 00				$binarioLongitud BYTE 0
 0000060D 00000000			$TAG DWORD ?
 00000611 00000000			$SIC DWORD ?
 00000615 00000000			$BIC DWORD ?
 00000619 00000000			$WIB DWORD ?

					; ----------------------------
					; Variables dedicadas del módulo 1
					; ----------------------------
 0000061D 50 61 72 74 69		$modulo1Name BYTE "Particionamiento de bits de direcciones", 0dh, 0ah, 0dh, 0ah, 0
	   63 69 6F 6E 61
	   6D 69 65 6E 74
	   6F 20 64 65 20
	   62 69 74 73 20
	   64 65 20 64 69
	   72 65 63 63 69
	   6F 6E 65 73 0D
	   0A 0D 0A 00
 00000649 45 73 71 75 65		$selectMapeoStr BYTE "Esquema de cache: Directo(0), Asociativo(1): ", 0
	   6D 61 20 64 65
	   20 63 61 63 68
	   65 3A 20 44 69
	   72 65 63 74 6F
	   28 30 29 2C 20
	   41 73 6F 63 69
	   61 74 69 76 6F
	   28 31 29 3A 20
	   00
 00000677 0D 55 6E 69 64		$selectUnitStr BYTE 0dh, "Unidad en B(0), KB(1), MB(2): ", 0
	   61 64 20 65 6E
	   20 42 28 30 29
	   2C 20 4B 42 28
	   31 29 2C 20 4D
	   42 28 32 29 3A
	   20 00
 00000697 0D 54 61 6D 61		$selectMemPStr BYTE  0dh, "Tamanio de memoria principal: ", 0
	   6E 69 6F 20 64
	   65 20 6D 65 6D
	   6F 72 69 61 20
	   70 72 69 6E 63
	   69 70 61 6C 3A
	   20 00
 000006B7 0D 54 61 6D 61		$selectMemCStr BYTE  0dh, "Tamanio de memoria cache: ", 0
	   6E 69 6F 20 64
	   65 20 6D 65 6D
	   6F 72 69 61 20
	   63 61 63 68 65
	   3A 20 00
 000006D3 0D 54 61 6D 61		$selectBloqStr BYTE  0dh, "Tamanio del bloque: ", 0
	   6E 69 6F 20 64
	   65 6C 20 62 6C
	   6F 71 75 65 3A
	   20 00
 000006E9 0D 54 61 6D 61		$selectConjStr BYTE  0dh, "Tamanio de conjuntos: ", 0
	   6E 69 6F 20 64
	   65 20 63 6F 6E
	   6A 75 6E 74 6F
	   73 3A 20 00
 00000701 0D 44 69 72 65		$selectDirStr BYTE  0dh, "Direccion: ", 0
	   63 63 69 6F 6E
	   3A 20 00

					; ----------------------------
					; Variables dedicadas del módulo 2
					; ----------------------------
 0000070E 52 65 65 6D 70		$modulo2Name BYTE "Reemplazo de Bloques (FIFO)", 0dh, 0ah, 0dh, 0ah, 0
	   6C 61 7A 6F 20
	   64 65 20 42 6C
	   6F 71 75 65 73
	   20 28 46 49 46
	   4F 29 0D 0A 0D
	   0A 00
 0000072E 31 2D 20 43 61		$menu2Str BYTE "1- Cache de 8 bloques y 8 conjuntos.",0dh,0ah,
	   63 68 65 20 64
	   65 20 38 20 62
	   6C 6F 71 75 65
	   73 20 79 20 38
	   20 63 6F 6E 6A
	   75 6E 74 6F 73
	   2E 0D 0A 32 2D
	   20 43 61 63 68
	   65 20 64 65 20
	   31 36 20 62 6C
	   6F 71 75 65 73
	   20 79 20 38 20
	   63 6F 6E 6A 75
	   6E 74 6F 73 2E
	   0D 0A 33 2D 20
	   43 61 63 68 65
	   20 64 65 20 31
	   36 20 62 6C 6F
	   71 75 65 73 20
	   79 20 34 20 63
	   6F 6E 6A 75 6E
	   74 6F 73 2E 0D
	   0A 49 6E 74 72
	   6F 64 75 63 69
	   72 20 63 6F 6E
	   66 69 67 75 72
	   61 63 69 6F 6E
	   3A 20 00
								  "2- Cache de 16 bloques y 8 conjuntos.",0dh,0ah,
								  "3- Cache de 16 bloques y 4 conjuntos.",0dh,0ah,
								  "Introducir configuracion: ", 0
 000007BD 50 61 72 61 20		$LaSimBegin BYTE "Para salir, introducir la secuencia -1.",0
	   73 61 6C 69 72
	   2C 20 69 6E 74
	   72 6F 64 75 63
	   69 72 20 6C 61
	   20 73 65 63 75
	   65 6E 63 69 61
	   20 2D 31 2E 00
 000007E5 44 69 72 65 63		$DirStr BYTE "Direccion: ",0
	   63 69 6F 6E 3A
	   20 00
 000007F1 52 45 53 55 4C		$statsTotal BYTE "RESULTADOS",0dh,0ah,0dh,0ah,
	   54 41 44 4F 53
	   0D 0A 0D 0A 2D
	   20 54 6F 74 61
	   6C 20 64 65 20
	   73 6F 6C 69 63
	   69 74 75 64 65
	   73 20 61 20 63
	   61 63 68 65 3A
	   20 00
									"- Total de solicitudes a cache: ",0
 00000820 2D 20 46 61 6C		$statsFallas BYTE "- Fallas totales: ", 0
	   6C 61 73 20 74
	   6F 74 61 6C 65
	   73 3A 20 00
 00000833 09 2B 20 46 61		$statsFallasForz BYTE "	+ Fallas forzosas: ", 0
	   6C 6C 61 73 20
	   66 6F 72 7A 6F
	   73 61 73 3A 20
	   00
 00000848 09 2B 20 46 61		$statsFallasConf BYTE "	+ Fallas por conflicto: ", 0
	   6C 6C 61 73 20
	   70 6F 72 20 63
	   6F 6E 66 6C 69
	   63 74 6F 3A 20
	   00
 00000862 09 2B 20 54 61		$statsTasaFallas BYTE "	+ Tasa de fallas: ", 0
	   73 61 20 64 65
	   20 66 61 6C 6C
	   61 73 3A 20 00
 00000876 2D 20 41 63 69		$statsAciertos BYTE "- Aciertos: ", 0
	   65 72 74 6F 73
	   3A 20 00
 00000883 2D 20 54 61 73		$statsTasaAciertos BYTE "- Tasa de aciertos: ", 0
	   61 20 64 65 20
	   61 63 69 65 72
	   74 6F 73 3A 20
	   00
 00000898 46 61 6C 6C 61		$huboFallaForzosa BYTE "Falla forzosa.",0
	   20 66 6F 72 7A
	   6F 73 61 2E 00
 000008A7 46 61 6C 6C 61		$huboFallaConflicto BYTE "Falla por conflicto: ",0
	   20 70 6F 72 20
	   63 6F 6E 66 6C
	   69 63 74 6F 3A
	   20 00
 000008BD 41 63 69 65 72		$huboAcierto BYTE "Acierto.",0
	   74 6F 2E 00

 000008C6  00000011 [			$Cache SDWORD 17 DUP(-1) 
	    FFFFFFFF
	   ]
 0000090A  00000011 [			$FifoPointer SDWORD 17 DUP(-1) 
	    FFFFFFFF
	   ]
 0000094E 00000000			$NumeroDir SDWORD 0
 00000952 00				$SolicitudesTotales BYTE 0
 00000953 00			    $AciertosCount BYTE 0
 00000954 00				$FallaForzosaCount BYTE 0
 00000955 00				$FallaConflictoCount BYTE 0
 00000956 00000000			$FilasSize DWORD 0
 0000095A 00000000			$ColumnasSize DWORD 0
 0000095E 00000000			$AnchoReal DWORD 0
 00000962 01				$ShowMessagesMod1 BYTE 1 ; Boolan 
 00000963 00000000			$Conjunto DWORD 0 

				; ----------------------------
				; Sección de código
				; ----------------------------
 00000000			.code
					; ----------------------------
					; Realiza un salto de línea.
					; -------- params ------------
 00000000				Whiteline PROC 
 00000000  BA 00000000 R			mov edx, OFFSET $br_str
 00000005  E8 00000000 E			call WriteString
 0000000A  C3					ret
 0000000B				Whiteline ENDP

					; ----------------------------
					; Algoritmo de reemplazo FIFO, evalúa la próxima posición a sustituir cuando el conjunto está lleno.
					; -------- params ------------
					; esi : Dirección en X de la matriz (Contiene el valor del conjunto en donde se colocará la dirección).
					; $FifoPointer : Contiene información de la posición próxima a sustituir
					; $ColumnasSize : Tamaño interpretado de la columna máxima de la matriz actual 
					; $Cache : La matriz que contiene el caché
					; $NumeroDir : Dirección de memoria que se colocará en el caché
					; -------- return ------------
					; $Cache : Modifica el caché, reemplaza bloques 
					; $FifoPointer : Modificado internamente, para incrementar el contador respectivo del conjunto
					; ----------------------------	
 0000000B				FifoReplacement PROC 
						; Incremento el FIFO
 0000000B  8B 86 0000090A R			mov eax, [$FifoPointer + esi]
 00000011  8B D8				mov ebx, eax ; Guardo la posición actual en donde debo reemplazar
 00000013  83 C0 04				add eax, 4
 00000016  89 86 0000090A R			mov [$FifoPointer + esi], eax 

						; Verifico si el FIFO está lleno
 0000001C					lleno:
 0000001C  3B 05 0000095A R				cmp eax, $ColumnasSize
 00000022  7C 0A					jl nolleno ; Si es menor, no está lleno.
 00000024  C7 86 0000090A R				mov [$FifoPointer + esi], 0 ; Reinicio el fifo a 0 para que empiece otra véz
	   00000000

 0000002E					nolleno:
						; Escribo en pantalla a quién voy a reemplazar
 0000002E  8B 84 33				mov eax, [$Cache + esi + ebx] ; Obtengo elemento más reciente que ha entrado 
	   000008C6 R
 00000035  BA 000008A7 R			mov edx, OFFSET $huboFallaConflicto
 0000003A  E8 00000000 E			call WriteString 
 0000003F  E8 00000000 E			call WriteDec ; Imprimo el elemento que reemplazo
 00000044  E8 FFFFFFB7				call Whiteline
 00000049  FE 05 00000955 R			inc $FallaConflictoCount

						; Reemplazo el elemento que queda en FIFO por el nuevo
 0000004F  A1 0000094E R			mov eax, $NumeroDir
 00000054  89 84 33				mov [$Cache + esi + ebx], eax
	   000008C6 R

						; Termino la ejecución del programa
 0000005B  C3					ret
 0000005C				FifoReplacement ENDP

					; ----------------------------
					; Reemplaza bloques en memoria caché, chequea aciertos y fallas
					; -------- params ------------
					; $AnchoReal : Ancho físico de columnas
					; $FifoPointer : Contiene información de la posición próxima a sustituir
					; $ColumnasSize : Tamaño interpretado de la columna máxima de la matriz actual 
					; $Cache : La matriz que contiene el caché
					; $NumeroDir : Dirección de memoria que se colocará en el caché
					; -------- return ------------
					; $Cache : Modifica el caché, reemplaza bloques 
					; $FifoPointer : Modificado internamente, para incrementar el contador respectivo del conjunto
					; ----------------------------	
 0000005C				ReplacementCache PROC 
 0000005C  33 F6				xor esi, esi
 0000005E  33 FF				xor edi, edi ; Pongo esi y edi a cero
 00000060  F7 25 0000095E R			mul $AnchoReal
 00000066  C7 05 00000138 R			mov $DWnumero, 4
	   00000004
 00000070  F7 25 00000138 R			mul $DWnumero
 00000076  8B F0				mov esi, eax ; esi = Conjunto * Ancho  * 4(DWORD)
 00000078  BF 00000000				mov edi, 0 ; edi es el contador para moverme hacia la derecha
 0000007D					columna: ; hago la busqueda
 0000007D  8B 84 37					mov eax, [$Cache + esi + edi]
	   000008C6 R
 00000084  83 F8 FF					cmp eax, -1
 00000087  74 1A					je forzosa ; Si es -1, hay falla forzosa en ese sitio porque está vacío y salto a forzosa
 00000089  3B 05 0000094E R				cmp eax, $NumeroDir
 0000008F  74 48					je acierto ; Si hay un acierto en esa posición saltamos a acierto 
 00000091  83 C7 04					add edi, 4 ; Incrementamos de 4 en 4 por ser un DWORD
 00000094  3B 3D 0000095A R			cmp edi, $ColumnasSize
 0000009A  7E E1				jle columna

						; Si llega aquí, hay un reemplazo que se debe hacer por FIFO 
 0000009C					fifo_: 
 0000009C  E8 FFFFFF6A					call FifoReplacement
 000000A1  EB 4B					jmp salir

						; Hay falla forzosa
 000000A3					forzosa:
 000000A3  83 BE 0000090A R				cmp [$FifoPointer + esi], -1
	   FF
 000000AA  75 0A					jne nofifo ; Si fifo es -1, está vacío el conjunto porque nadie ha entrado
 000000AC  C7 86 0000090A R					mov [$FifoPointer + esi], 0 ; Incremento a 0 (primera posición ocupada)
	   00000000
 000000B6						nofifo:
 000000B6  A1 0000094E R					mov eax, $NumeroDir
 000000BB  89 84 37						mov [$Cache + esi + edi], eax ; Muevo al caché el número
	   000008C6 R
 000000C2  FE 05 00000954 R					inc $FallaForzosaCount 
 000000C8  BA 00000898 R					mov edx, OFFSET $huboFallaForzosa
 000000CD  E8 00000000 E					call WriteString
 000000D2  E8 FFFFFF29						call Whiteline
 000000D7  EB 15						jmp salir

						; Hay un acierto
 000000D9					acierto:
 000000D9  BA 000008BD R				mov edx, OFFSET $huboAcierto
 000000DE  E8 00000000 E				call WriteString
 000000E3  E8 FFFFFF18					call Whiteline
 000000E8  FE 05 00000953 R				inc $AciertosCount

 000000EE					salir:
 000000EE  C3						ret
 000000EF				ReplacementCache ENDP

					; ----------------------------
					; Muestra las estadísticas en pantalla 
					; -------- params ------------
					; $SolicitudesTotales : Solicitudes totales realizadas a caché
					; $FallaConflictoCount : Contador de fallas por conflicto
					; $FallaForzosaCount : Contador de fallas forzosas 
					; $AciertosCount : Contador de aciertos totales
					; ----------------------------	
 000000EF				ShowReplacementStats PROC
						; Total solicitudes a caché
 000000EF  BA 000007F1 R			mov edx, OFFSET $statsTotal 
 000000F4  E8 00000000 E			call WriteString 
 000000F9  0F B6 05				movzx eax, $SolicitudesTotales
	   00000952 R
 00000100  E8 00000000 E			call WriteDec
 00000105  E8 FFFFFEF6				call Whiteline

						; Total de fallas
 0000010A  BA 00000820 R			mov edx, OFFSET $statsFallas 
 0000010F  E8 00000000 E			call WriteString 
 00000114  0F B6 05				movzx eax, $FallaConflictoCount
	   00000955 R
 0000011B  0F B6 15				movzx edx, $FallaForzosaCount
	   00000954 R
 00000122  03 C2				add eax, edx
 00000124  E8 00000000 E			call WriteDec
 00000129  E8 FFFFFED2				call Whiteline

						; Fallas forzosas
 0000012E  BA 00000833 R			mov edx, OFFSET $statsFallasForz
 00000133  E8 00000000 E			call WriteString 
 00000138  0F B6 05				movzx eax, $FallaForzosaCount
	   00000954 R
 0000013F  E8 00000000 E			call WriteDec
 00000144  E8 FFFFFEB7				call Whiteline

						; Fallas por conflicto
 00000149  BA 00000848 R			mov edx, OFFSET $statsFallasConf 
 0000014E  E8 00000000 E			call WriteString 
 00000153  0F B6 05				movzx eax, $FallaConflictoCount
	   00000955 R
 0000015A  E8 00000000 E			call WriteDec
 0000015F  E8 FFFFFE9C				call Whiteline

						; Tasa de fallas
 00000164  BA 00000862 R			mov edx, OFFSET $statsTasaFallas
 00000169  E8 00000000 E			call WriteString 
 0000016E  0F B6 05				movzx eax, $FallaConflictoCount 
	   00000955 R
 00000175  0F B6 15				movzx edx, $FallaForzosaCount
	   00000954 R
 0000017C  03 C2				add eax, edx ; Obtengo fallasTotales
 0000017E  C7 05 00000138 R			mov $DWnumero, 100
	   00000064
 00000188  F7 25 00000138 R			mul $DWnumero ; fallasTotales * 100 
 0000018E  0F B6 15				movzx edx, $SolicitudesTotales
	   00000952 R
 00000195  E8 0000027F				call Division ; (fallasTotales * 100) / SolicitudesTotales
 0000019A  E8 00000000 E			call WriteDec ; Imprimo la parte entera 
 0000019F  33 C0				xor eax, eax ; Limpio eax
 000001A1  B0 2E				mov al, '.'
 000001A3  E8 00000000 E			call WriteChar ; Imprimo el punto 
 000001A8  8B C2				mov eax, edx 
 000001AA  E8 00000000 E			call WriteDec ; Imprimo la parte decimal
 000001AF  33 C0				xor eax, eax ; Limpio eax
 000001B1  B0 25				mov al, '%'
 000001B3  E8 00000000 E			call WriteChar ; Imprimo el signo de porcentaje
 000001B8  E8 FFFFFE43				call Whiteline

						; Aciertos totales
 000001BD  BA 00000876 R			mov edx, OFFSET $statsAciertos 
 000001C2  E8 00000000 E			call WriteString
 000001C7  0F B6 05				movzx eax, $AciertosCount
	   00000953 R
 000001CE  E8 00000000 E			call WriteDec 
 000001D3  E8 FFFFFE28				call Whiteline

						; Tasa de aciertos
 000001D8  BA 00000883 R			mov edx, OFFSET $statsTasaAciertos 
 000001DD  E8 00000000 E			call WriteString 
 000001E2  0F B6 05				movzx eax, $AciertosCount
	   00000953 R
 000001E9  C7 05 00000138 R			mov $DWnumero, 100
	   00000064
 000001F3  F7 25 00000138 R			mul $DWnumero ; AciertosCount * 100 
 000001F9  0F B6 15				movzx edx, $SolicitudesTotales
	   00000952 R
 00000200  E8 00000214				call Division ; (AciertosCount * 100) / SolicitudesTotales
 00000205  E8 00000000 E			call WriteDec ; Imprimo la parte entera 
 0000020A  33 C0				xor eax, eax ; Limpio eax
 0000020C  B0 2E				mov al, '.'
 0000020E  E8 00000000 E			call WriteChar ; Imprimo el punto 
 00000213  8B C2				mov eax, edx 
 00000215  E8 00000000 E			call WriteDec ; Imprimo la parte decimal
 0000021A  33 C0				xor eax, eax ; Limpio eax
 0000021C  B0 25				mov al, '%'
 0000021E  E8 00000000 E			call WriteChar ; Imprimo el signo de porcentaje
 00000223  E8 FFFFFDD8				call Whiteline

 00000228  C3					ret
 00000229				ShowReplacementStats ENDP

					; ----------------------------
					; Muestra la matriz de caché en la pantalla
					; -------- params ------------
					; $FilasSize : Filas interpretadas de la matriz
					; $ColumnasSize : Columnas interpretadas de la matriz
					; $AnchoReal : Ancho físico de columnas
					; ----------------------------
 00000229				ShowCache PROC 
						; esi empieza en cero
 00000229  BE 00000000				mov esi, 0
 0000022E  C6 05 0000012F R			mov $contador, 0
	   00
						; while esi <= FilasSize
 00000235					filas:
							; Muestro que conjunto es el actual
 00000235  B0 43					mov al, 'C'
 00000237  E8 00000000 E				call WriteChar
 0000023C  0F B6 05					movzx eax, $contador
	   0000012F R
 00000243  E8 00000000 E				call WriteDec
 00000248  B0 3A					mov al, ':'
 0000024A  E8 00000000 E				call WriteChar
 0000024F  B0 20					mov al, ' '
 00000251  E8 00000000 E				call WriteChar

 00000256  56						push esi ; apilo
 00000257  BF 00000000					mov edi, 0 ; edi empieza en cero
							; while edi <= FilasSize
 0000025C						columnas:
 0000025C  57							push edi ; apilo

									; Paréntesis izquierdo
 0000025D  B0 5B							mov al, '['
 0000025F  E8 00000000 E						call WriteChar

									; esi *= AnchoReal
 00000264  33 C0							xor eax, eax
 00000266  8B C6							mov eax, esi
 00000268  89 35 00000138 R						mov $DWnumero, esi ; Guardo el esi actual
 0000026E  F7 25 0000095E R						mul $AnchoReal
 00000274  8B F0							mov esi, eax 

									; Obtengo el número actual
 00000276  8B 84 37							mov eax, [$Cache + esi + edi]
	   000008C6 R
					
 0000027D  8B 35 00000138 R						mov esi, $DWnumero ; Regreso el esi a como estaba

 00000283  83 F8 00							cmp eax, 0
 00000286  7C 09							jl vacio ; eax < 0, es porque la posición está vacía "-1"
 00000288  7D 00							jge novacio ; eax >= 0, es porque en la posición si existe un número que mostrar

									; Si no está vacío, imprimo el número
 0000028A								novacio:	
 0000028A  E8 00000000 E							call WriteDec
 0000028F  EB 07							jmp cerrarparentesis

									; Si está vacío, imprimo un charter blanco
 00000291								vacio: 
 00000291  B0 20								mov al, ' '
 00000293  E8 00000000 E							call WriteChar

 00000298								cerrarparentesis:
										; Paréntesis derecho
 00000298  B0 5D								mov al, ']'
 0000029A  E8 00000000 E							call WriteChar
					
 0000029F  5F							pop edi
 000002A0  83 C7 04						add edi, 4 ; edi+=4
 000002A3  3B 3D 0000095A R				cmp edi, $ColumnasSize
 000002A9  7E B1					jle columnas ; edi <= ColumnasSize
 000002AB  5E						pop esi
 000002AC  83 C6 04				add esi, 4 ; esi+=4
 000002AF  FE 05 0000012F R			inc $contador ; Incremento el contador
						; salto de línea
 000002B5  E8 FFFFFD46				call Whiteline
 000002BA  3B 35 00000956 R			cmp esi, $FilasSize
 000002C0  0F 8E FFFFFF6F			jle filas ; esi <= $FilasSize
						
						; Salgo
 000002C6  C3					ret
 000002C7				ShowCache ENDP

					; ----------------------------------
					;  Resetea la variable binaria 
					; ----------------------------------
 000002C7				ResetBin PROC 
 000002C7  C6 05 0000060C R			mov $binarioLongitud, 0
	   00
 000002CE  B9 000001FF				mov ecx, 511
 000002D3					ciclo:
 000002D3  C6 81 00000340 R				mov [$binario + ecx], '0'
	   30
 000002DA  E2 F7				loop ciclo
 000002DC  C6 05 00000340 R			mov [$binario], '0'
	   30
 000002E3  C3					ret 
 000002E4				ResetBin ENDP

					; ----------------------------------
					;  Resetea la variable binaria de sic/BIC
					; ----------------------------------
 000002E4				ResetBinDec PROC 
 000002E4  C7 05 00000608 R			mov $binarioSICBICLongitud, 0
	   00000000
 000002EE  B9 000000C7				mov ecx, 199
 000002F3					ciclo:
 000002F3  C6 81 00000540 R				mov [$binarioSICBIC + ecx], '0'
	   30
 000002FA  E2 F7				loop ciclo
 000002FC  C6 05 00000540 R			mov [$binarioSICBIC], '0'
	   30
 00000303  C3					ret
 00000304				ResetBinDec ENDP

					; ----------------------------------
					; Resetea la variable binaria del bloque de caché
					; ----------------------------------
 00000304				ResetBloqueCache PROC 
 00000304  C7 05 0000033C R			mov $BloqueCacheLongitud, 0
	   00000000
 0000030E  B9 000001FF		 	    mov ecx, 511
 00000313					ciclo: 
 00000313  C6 81 0000013C R				mov [$BloqueCache + ecx], '0'
	   30
 0000031A  E2 F7				loop ciclo
 0000031C  C6 05 0000013C R			mov [$BloqueCache], '0'
	   30
 00000323  C3					ret
 00000324				ResetBloqueCache ENDP

					; ----------------------------------
					; Resetea el $Cache
					; ----------------------------------
 00000324				ResetCache PROC
 00000324  BE 00000010				mov esi, 16
 00000329					limpiar:
 00000329  C7 04 B5					mov [$Cache + esi*4], -1
	   000008C6 R
	   FFFFFFFF
 00000334  4E						dec esi 
 00000335  83 FE 00				cmp esi, 0
 00000338  7D EF				jge limpiar
 0000033A				ResetCache ENDP

					; ----------------------------------
					; Resetea el $FifoPointer
					; ----------------------------------
 0000033A				ResetFifoPointer PROC
 0000033A  BE 00000010				mov esi, 16
 0000033F					limpiar:
 0000033F  C7 04 B5					mov [$FifoPointer + esi*4], -1
	   0000090A R
	   FFFFFFFF
 0000034A  4E						dec esi 
 0000034B  83 FE 00				cmp esi, 0
 0000034E  7D EF				jge limpiar
 00000350				ResetFifoPointer ENDP

					; ----------------------------------
					; Limpia variables del módulo 1
					; ----------------------------------
 00000350				ResetMod1 PROC 
 00000350  C7 05 00000619 R			mov $WIB, 0
	   00000000
 0000035A  C7 05 0000060D R			mov $TAG, 0
	   00000000
 00000364  C7 05 00000611 R			mov $SIC, 0
	   00000000
 0000036E  C7 05 00000615 R			mov $BIC, 0
	   00000000
 00000378  E8 FFFFFF4A				call ResetBin
 0000037D  E8 FFFFFF62				call ResetBinDec
 00000382  E8 FFFFFF7D				call ResetBloqueCache
 00000387  C3					ret 
 00000388				ResetMod1 ENDP 

					; ----------------------------------
					; Limpia variables del módulo 2
					; ----------------------------------
 00000388				ResetMod2 PROC 
 00000388  C6 05 00000952 R			mov $SolicitudesTotales, 0 
	   00
 0000038F  C6 05 00000953 R			mov $AciertosCount, 0
	   00
 00000396  C6 05 00000954 R			mov $FallaForzosaCount, 0
	   00
 0000039D  C6 05 00000955 R			mov $FallaConflictoCount, 0
	   00
 000003A4  C7 05 00000956 R			mov $FilasSize, 0
	   00000000
 000003AE  C7 05 0000095A R			mov $ColumnasSize, 0
	   00000000
 000003B8  C7 05 0000095E R			mov $AnchoReal, 0
	   00000000
 000003C2  C6 05 00000962 R			mov $ShowMessagesMod1, 0
	   00
 000003C9  C7 05 00000963 R			mov $Conjunto, 0
	   00000000
 000003D3  E8 FFFFFF4C				call ResetCache
 000003D8  E8 FFFFFF5D				call ResetFifoPointer
 000003DD  C3					ret 
 000003DE				ResetMod2 ENDP 

					; ----------------------------
					; Multiplica un número por si mismo (Eleva a potencia)
					; -------- params ------------
					; eax : El número base
					; $DWnumero : Tantas veces como se va a multiplicar por sí mismo
					; -------- return ------------
					; eax : Resultado de la operación
					; ----------------------------	
 000003DE				Raise PROC
 000003DE  83 F8 01				cmp eax, 1
 000003E1  7C 27				jl es_cero ; 0 * DWnumero
 000003E3  74 2C				je es_uno ; 1 * DWnumero
 000003E5  83 3D 00000138 R			cmp $DWnumero, 1
	   01
 000003EC  7C 15				jl es_cero_d ; eax * 0
 000003EE  74 28				je fin ; eax * 1

						; while eax > 1
 000003F0					mientras:
 000003F0  03 C0					add eax, eax
 000003F2  FF 0D 00000138 R				dec $DWnumero
 000003F8  83 3D 00000138 R			cmp $DWnumero, 1
	   01
 000003FF  7F EF				jg mientras
 00000401  7E 15				jle fin

						; $DWnumero == 0
 00000403					es_cero_d:
 00000403  B8 00000000					mov eax, 0
 00000408  EB 0E					jmp fin

						; eax == 0
 0000040A					es_cero:
 0000040A  B8 00000000					mov eax, 0
 0000040F  EB 07					jmp fin

						; eax == 1
 00000411					es_uno:
 00000411  A1 00000138 R				mov eax, $DWnumero
 00000416  EB 00					jmp fin
							
 00000418					fin:
 00000418  C3						ret
 00000419				Raise ENDP

					; ----------------------------
					; Divide un número (mejora el funcionamiento de DIV en ASM)
					; -------- params ------------
					; eax : Dividendo
					; edx : Divisor
					; -------- return ------------
					; edx : Residuio de la operación
					; eax : Cociente de la operación
					; ----------------------------	
 00000419				Division PROC
 00000419  C7 05 00000130 R			mov $divcounter, 0
	   00000000
 00000423  83 F8 01				cmp eax, 1
 00000426  7C 13				jl es_cero
 00000428  74 18				je es_uno

						; while eax > 1
 0000042A					mientras:
 0000042A  2B C2					sub eax, edx
 0000042C  FF 05 00000130 R				inc $divcounter
 00000432  83 F8 01				cmp eax, 1
 00000435  7F F3				jg mientras
 00000437  74 09				je es_uno
 00000439  7C 00				jl es_cero	

						; eax == 0
 0000043B					es_cero:
 0000043B  BA 00000000					mov edx, 0
 00000440  EB 07					jmp fin

						; eax == 1
 00000442					es_uno:
 00000442  BA 00000001					mov edx, 1
 00000447  EB 00					jmp fin
							
 00000449					fin:
 00000449  A1 00000130 R				mov eax, $divcounter
 0000044E  C3						ret
 0000044F				Division ENDP

					; ----------------------------
					; Lleva un número da la expresión 2^n a su expresión decimal
					; -------- params ------------
					; eax : n veces a elevar
					; -------- return ------------
					; eax : Resultado de la operación 
					; ----------------------------	
 0000044F				Base2 PROC
 0000044F  83 F8 00				cmp eax, 0
 00000452  74 07				je si_es_cero
 00000454  83 F8 01				cmp eax, 1
 00000457  74 09				je si_es_uno
 00000459  7F 0E				jg si_mayor_uno
						
 0000045B					si_es_cero:
 0000045B  B8 00000001					mov eax, 1 ; devuelvo uno
 00000460  EB 23				jmp scape

 00000462					si_es_uno:
 00000462  B8 00000002					mov eax, 2 ; devuelvo dos
 00000467  EB 1C				jmp scape

 00000469					si_mayor_uno:
 00000469  8B D0					mov edx, eax
 0000046B  B8 00000001					mov eax, 1
 00000470						mientras:
 00000470  C7 05 00000138 R					mov $DWnumero, 2
	   00000002
 0000047A  E8 FFFFFF5F						call Raise
 0000047F  4A							dec edx ; decremento para control del bucle
 00000480  83 FA 00					cmp edx, 0
 00000483  7F EB					jg mientras ; edx > 0
						
 00000485					scape:
 00000485  C3					ret
 00000486				Base2 ENDP

					; ----------------------------
					; Transforma un número entero al binario correspondiente
					; -------- params ------------
					; $binario : Variable que almacena el vector lleno de '0' inicialmente.
					; eax : Número a transformar, termina siendo cero. 
					; -------- return ------------
					; $binario : Modifica el vector, en función del binario obtenido (BYTE de chars)
					; ---> $binario contiene el binario, pero por defecto está volteado "para su uso posterior conviene así"
					; ecx : Longitud del binario
					; ----------------------------
 00000486				IntToBin PROC
 00000486  33 C9				xor ecx, ecx
 00000488  83 F8 00				cmp eax, 0
 0000048B  7E 1C				jle scape; eax <= 0

						; while : eax > 0
 0000048D					mientras:
							; Divido eax / edx, obtengo residuio en edx
 0000048D  BA 00000002					mov edx, 2
 00000492  E8 FFFFFF82					call Division

							; IF edx != 1, si edx == 1 se añade el char
 00000497  83 FA 01					cmp edx, 1
 0000049A  75 07					jne incremento
 0000049C  C6 81 00000340 R					mov[$binario + ecx], '1'
	   31

 000004A3						incremento :
 000004A3  41							inc ecx; incremento de ecx

 000004A4  83 F8 00				cmp eax, 0
 000004A7  7F E4				jg mientras

 000004A9					scape:
 000004A9  C3						ret
 000004AA				IntToBin ENDP

					; ----------------------------
					; Transforma un vector binario a un número entero.
					; -------- params ------------
					; $binario : Variable que almacena el vector con el binario a transformar.
					; ecx : Longitud del binario (SI NO DESEO PERDER SU VALOR, DEBO GUARDARLO)
					; -------- return ------------
					; eax : Es modificado (el lleva el exponente del bit)
					; ecx : Es modificado (lleva el contador del binario)
					; edx : Controla el bucle interno en Base2
					; ebx : Resultado de la operación (entero convertido)
					; ----------------------------
 000004AA				BinToInt PROC
 000004AA  33 DB				xor ebx, ebx
 000004AC  33 C9				xor ecx, ecx
 000004AE  3B 0D 00000608 R			cmp ecx, $binarioSICBICLongitud
 000004B4  7D 23				jge fin
 000004B6					ciclo:
 000004B6  8A 91 00000540 R				mov dl, [$binarioSICBIC + ecx]
 000004BC  80 FA 31					cmp dl, '1'

 000004BF  75 0F					jne scape
							; if ([$binarioSICBIC + ecx] == '1')
 000004C1  A1 00000608 R					mov eax, $binarioSICBICLongitud
 000004C6  2B C1						sub eax, ecx
 000004C8  48							dec eax
 000004C9  E8 FFFFFF81						call Base2
 000004CE  03 D8						add ebx, eax
 000004D0						scape:
 000004D0  41							inc ecx; incremento ecx
 000004D1  3B 0D 00000608 R			cmp ecx, $binarioSICBICLongitud
 000004D7  7C DD				jl ciclo
						
 000004D9					fin:
 000004D9  C3						ret
 000004DA				BinToInt ENDP

					; ----------------------------
					; Convierte un número de MB, KB, B a Bytes
					; -------- params ------------
					; eax : Número
					; ecx : Unidad actual (Mb=2/Kb=1/B=0)
					; -------- return ------------
					; eax : Número transformado
					; ----------------------------
 000004DA				UnitConversor PROC
 000004DA  83 FB 02				cmp ebx, 2
 000004DD  74 0D				je si2
 000004DF  83 FB 01				cmp ebx, 1
 000004E2  75 16				jne scape

						; KB
 000004E4					si1:
 000004E4  F7 25 0000010F R				mul $n1024
 000004EA  EB 0E				jmp scape

						; MB
 000004EC					si2:
 000004EC  F7 25 0000010F R				mul $n1024
 000004F2  F7 25 0000010F R				mul $n1024
 000004F8  EB 00				jmp scape

						;Byte
 000004FA					scape:
 000004FA  C3						ret
 000004FB				UnitConversor ENDP

					; ----------------------------
					; Obtiene el exponente 'n' de un número que se pueda expresar como 2^n
					; -------- params ------------
					; eax : Número
					; edx : Es modificado internamente
					; -------- return ------------
					; edx : Resultado, devuelve 'n'
					; ----------------------------
 000004FB				GetExponent PROC
						; Reseteo edx //
 000004FB  C6 05 0000012F R			mov $contador, 0
	   00

						; Que regrese cero si es 1 eax
 00000502  83 F8 01				cmp eax, 1
 00000505  7F 0C				jg mientras
 00000507  BA 00000000				mov edx, 0
 0000050C  EB 1A				jmp scape

 0000050E  83 F8 00				cmp eax, 0
 00000511  7E 15				jle scape ; eax <= 0

						; while : eax > 0
 00000513					mientras:
 00000513  BA 00000002					mov edx, 2
 00000518  E8 FFFFFEFC					call Division
 0000051D  FE 05 0000012F R				inc $contador ; incremento de ecx
 00000523  83 F8 01				cmp eax, 1
 00000526  7F EB				jg mientras

						; Salgo
 00000528					scape:
 00000528  0F B6 15					movzx edx, $contador ; Doy la respuesta, del n //
	   0000012F R
 0000052F  C3						ret
 00000530				GetExponent ENDP

					; ----------------------------
					; Módulo 1 (Menú y operaciones)
					; Es reutilizado todo en el módulo 2
					; -------- params ------------
					; $ShowMessagesMod1 : Booleana (interpretada), que dice si se va a mostrar o no información en pantalla.
					; -------- return ------------
					; Conjunto : Si se llama desde el módulo 2, devuelve el conjunto en el que se coloca una dirección.
					; ----------------------------
 00000530				modulo1 PROC
 00000530  E8 FFFFFE1B				call ResetMod1
					
						; Verificamos si estamos accediendo desde el módulo 2
 00000535  80 3D 00000962 R			cmp $ShowMessagesMod1, 0
	   00
 0000053C  0F 84 00000121			je mostrarenconsola ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones

 00000542  E8 00000000 E			call ClrScr
						
						; Título del módulo 
 00000547  BA 0000061D R			mov edx, OFFSET $modulo1Name
 0000054C  E8 00000000 E			call WriteString

						; Seleccionar mapeo
 00000551  BA 00000649 R			mov edx, OFFSET $selectMapeoStr
 00000556  E8 00000000 E			call WriteString
 0000055B  E8 00000000 E			call ReadDec
 00000560  A3 00000113 R			mov [$config], eax

						; Tamaño memoria principal
 00000565  BA 00000697 R			mov edx, OFFSET $selectMemPStr
 0000056A  E8 00000000 E			call WriteString
 0000056F  E8 00000000 E			call ReadDec
 00000574  A3 00000117 R			mov [$config + 4], eax

						; Unidad de la memoria 
 00000579  BA 00000677 R			mov edx, OFFSET $selectUnitStr
 0000057E  E8 00000000 E			call WriteString
 00000583  E8 00000000 E			call ReadDec
 00000588  A3 0000012B R			mov [$config + 24], eax; Recibo la unidad 
 0000058D  A1 00000117 R			mov eax, [$config + 4] ; Coloco de nuevo el valor de la memoria introducido antes para UnitConversor 
 00000592  8B 1D 0000012B R			mov ebx, [$config + 24]; Guardo la unidad en ebx para UnitConversor 
 00000598  E8 FFFFFF3D				call UnitConversor
 0000059D  A3 00000117 R			mov [$config + 4], eax

						; Salto de linea 
 000005A2  E8 FFFFFA59				call Whiteline

						; Tamaño memoria cache 
 000005A7  BA 000006B7 R			mov edx, OFFSET $selectMemCStr
 000005AC  E8 00000000 E			call WriteString
 000005B1  E8 00000000 E			call ReadDec
 000005B6  A3 0000011B R			mov [$config + 8], eax
						
						; Unidad de la memoria 
 000005BB  BA 00000677 R			mov edx, OFFSET $selectUnitStr
 000005C0  E8 00000000 E			call WriteString
 000005C5  E8 00000000 E			call ReadDec
 000005CA  A3 0000012B R			mov [$config + 24], eax; Recibo la unidad 
 000005CF  A1 0000011B R			mov eax, [$config + 8]; Coloco de nuevo el valor de la memoria introducido antes para UnitConversor 
 000005D4  8B 1D 0000012B R			mov ebx, [$config + 24]; Guardo la unidad en ebx para UnitConversor 
 000005DA  E8 FFFFFEFB				call UnitConversor
 000005DF  A3 0000011B R			mov [$config + 8], eax

						; Salto de linea 
 000005E4  E8 FFFFFA17				call Whiteline

						; Tamaño de bloques 
 000005E9  BA 000006D3 R			mov edx, OFFSET $selectBloqStr
 000005EE  E8 00000000 E			call WriteString
 000005F3  E8 00000000 E			call ReadDec
 000005F8  A3 0000011F R			mov [$config + 12], eax

						; Unidad de la memoria 
 000005FD  BA 00000677 R			mov edx, OFFSET $selectUnitStr
 00000602  E8 00000000 E			call WriteString
 00000607  E8 00000000 E			call ReadDec
 0000060C  A3 0000012B R			mov [$config + 24], eax; Recibo la unidad 
 00000611  A1 0000011F R			mov eax, [$config + 12]; Coloco de nuevo el valor de la memoria introducido antes para UnitConversor   
 00000616  8B 1D 0000012B R			mov ebx, [$config + 24]; Guardo la unidad en ebx para UnitConversor 
 0000061C  E8 FFFFFEB9				call UnitConversor
 00000621  A3 0000011F R			mov [$config + 12], eax

						; Salto de linea 
 00000626  E8 FFFFF9D5				call Whiteline

						; Tamaño de conjuntos SI es asociativo 
 0000062B  8B 15 00000113 R			mov edx, [$config]
 00000631  83 FA 01				cmp edx, 1
 00000634  75 19				jne si1_nocumple ; edx != 1, si edx == 1 entra en si1:
 00000636					si1:
 00000636  BA 000006E9 R				mov edx, OFFSET $selectConjStr
 0000063B  E8 00000000 E				call WriteString
 00000640  E8 00000000 E				call ReadDec
 00000645  A3 00000123 R				mov [$config + 16], eax

							; Salto de linea 
 0000064A  E8 FFFFF9B1					call Whiteline
 0000064F					si1_nocumple:

						; Dirección de memoria 
 0000064F  BA 00000701 R			mov edx, OFFSET $selectDirStr
 00000654  E8 00000000 E			call WriteString
 00000659  E8 00000000 E			call ReadDec
 0000065E  A3 00000127 R			mov [$config + 20], eax

						; Si llega aquí, fue por un salto implicito desde el módulo 2 o por el flujo normal
 00000663					mostrarenconsola:

						; Transformo la direccion de memoria a binario que está en eax 
 00000663  E8 FFFFFE1E				call IntToBin
						; ecx tiene la longitud del binario 
 00000668  49					dec ecx ; Disminuyo el exceso de ecx para recorrer las posiciones del binario
 00000669  88 0D 0000060C R			mov $binarioLongitud, cl ; Guardar la longitud del binario

						; TAG = Memoria principal(en bytes) / memoria cache(bytes), en potencia de 2
						; BIC = Memoria caché (en bytes) / bloques(en bytes), en potencia de 2
						; WIB = bloques(en bytes), en potencia de 2
						; Calculo en mapeo directo
 0000066F  8B 15 00000113 R			mov edx, [$config]
 00000675  83 FA 00				cmp edx, 0
 00000678  75 46				jne si2_nocumple ; edx != 0, si edx == 0 entra en si2:
 0000067A					si2:
							; Creación del TAG 
 0000067A  A1 00000117 R				mov eax, [$config + 4]
 0000067F  E8 FFFFFE77					call GetExponent 
 00000684  89 15 0000060D R				mov $TAG, edx ; A TAG le asigno edx, que será el exponente de mem principal
 0000068A  A1 0000011B R				mov eax, [$config + 8]
 0000068F  E8 FFFFFE67					call GetExponent 
 00000694  29 15 0000060D R				sub $TAG, edx ; A TAG (exp. memppal) le resto el exp. de mem cache

							; Creación del BIC 
 0000069A  A1 0000011B R				mov eax, [$config + 8]
 0000069F  E8 FFFFFE57					call GetExponent
 000006A4  89 15 00000615 R				mov $BIC, edx; A BIC le asigno ecx, que será el exponente de bloque
 000006AA  A1 0000011F R				mov eax, [$config + 12]
 000006AF  E8 FFFFFE47					call GetExponent
 000006B4  29 15 00000615 R				sub $BIC, edx; A BIC (exp. memcach) le resto el exp. de bloque

							; Creación del WIB 
 000006BA  89 15 00000619 R				mov $WIB, edx; Por la operación anterior, en edx estaba el BIC
 000006C0					si2_nocumple:

						; TAG = M.P - SIC - WIB
						; SIC = (Memoria caché (en bytes) / bloques (en bytes)) / tamaño de conjunto, en potencia de 2
						; WIB = bloques(en bytes), en potencia de 2
						; Calculo en mapeo asociativo por conjunto
 000006C0  8B 15 00000113 R			mov edx, [$config]
 000006C6  83 FA 01				cmp edx, 1
 000006C9  75 61				jne si3_nocumple ; edx != 1, si edx == 1 entra en si3:
 000006CB					si3:
							; Creación del WIB 
 000006CB  A1 0000011F R				mov eax, [$config + 12]
 000006D0  E8 FFFFFE26					call GetExponent
 000006D5  89 15 00000619 R				mov $WIB, edx

							; Creación del SIC 
 000006DB  A1 0000011B R				mov eax, [$config + 8]
 000006E0  E8 FFFFFE16					call GetExponent
 000006E5  89 15 00000611 R				mov $SIC, edx
 000006EB  A1 00000619 R				mov eax, $WIB
 000006F0  29 05 00000611 R				sub $SIC, eax
 000006F6  A1 00000123 R				mov eax, [$config + 16]
 000006FB  E8 FFFFFDFB					call GetExponent
 00000700  29 15 00000611 R				sub $SIC, edx

							; Creación del TAG
 00000706  A1 00000117 R				mov eax, [$config + 4]
 0000070B  E8 FFFFFDEB					call GetExponent
 00000710  89 15 0000060D R				mov $TAG, edx
 00000716  A1 00000611 R				mov eax, $SIC
 0000071B  29 05 0000060D R				sub $TAG, eax
 00000721  A1 00000619 R				mov eax, $WIB 
 00000726  29 05 0000060D R				sub $TAG, eax		
 0000072C					si3_nocumple:

						; Defino el tamaño del vector BloqueCache
 0000072C  A1 0000060D R			mov eax, $TAG 
 00000731  03 05 00000615 R			add eax, $BIC 
 00000737  03 05 00000611 R			add eax, $SIC 
 0000073D  03 05 00000619 R			add eax, $WIB 
 00000743  48					dec eax
 00000744  A3 0000033C R			mov $BloqueCacheLongitud, eax ; TAG + BIC + SIC + WIB

						; LLENO BloqueCache con binario, en las ultimas posiciones de binario 
 00000749  33 C9				xor ecx, ecx
 0000074B  33 C0				xor eax, eax
 0000074D  3A 0D 0000060C R			cmp cl, $binarioLongitud
 00000753  7F 1D				jg finmientras1 ; cl > binarioLongitud salta, si no entra en el while
						; while : cl <= binarioLongitud
 00000755					mientras1:
 00000755  8A 91 00000340 R				mov dl, [$binario + ecx]
 0000075B  A1 0000033C R				mov eax, $BloqueCacheLongitud
 00000760  2B C1					sub eax, ecx
 00000762  88 90 0000013C R				mov[$BloqueCache + eax], dl
 00000768  FE C1					inc cl
 0000076A  3A 0D 0000060C R				cmp cl, $binarioLongitud
 00000770  7E E3				jle mientras1
 00000772					finmientras1: 

 00000772  80 3D 00000962 R			cmp $ShowMessagesMod1, 0
	   00
 00000779  74 0F				je mostrarenconsola2 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
							; Salto de línea 
 0000077B  E8 FFFFF880					call Whiteline
						
							; Mostrar el TAG 
 00000780  BA 0000009C R				mov edx, OFFSET $sTAG
 00000785  E8 00000000 E				call WriteString
 0000078A					mostrarenconsola2:

 0000078A  33 C9				xor ecx, ecx
 0000078C  33 C0				xor eax, eax
 0000078E  3B 0D 0000060D R			cmp ecx, $TAG
 00000794  7D 2B				jge finmientras2 ; ecx >= TAG no entra, si es < TAG sí
 00000796					mientras2:
 00000796  80 3D 00000962 R				cmp $ShowMessagesMod1, 0
	   00
 0000079D  74 19					je mostrarenconsola3 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
 0000079F  B0 5B						mov al, '['
 000007A1  E8 00000000 E					call WriteChar
 000007A6  8A 81 0000013C R					mov al, [$BloqueCache + ecx]
 000007AC  E8 00000000 E					call WriteChar
 000007B1  B0 5D						mov al, ']'
 000007B3  E8 00000000 E					call WriteChar
 000007B8						mostrarenconsola3:
 000007B8  41							inc ecx
 000007B9  3B 0D 0000060D R			cmp ecx, $TAG
 000007BF  7C D5				jl mientras2 ; ecx < TAG
 000007C1					finmientras2:

 000007C1  80 3D 00000962 R			cmp $ShowMessagesMod1, 0
	   00
 000007C8  74 05				je mostrarenconsola4 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
							; Salto de línea 
 000007CA  E8 FFFFF831					call Whiteline
 000007CF					mostrarenconsola4:

 000007CF  8B 15 00000113 R			mov edx, [$config]
 000007D5  83 FA 00				cmp edx, 0
 000007D8  75 06				jne sibic_nocumple ; edx != 0, si edx == 0 entra en sibic:
 000007DA  8B 1D 00000615 R				mov ebx, $BIC
 000007E0					sibic_nocumple:
 000007E0  83 FA 01					cmp edx, 1
 000007E3  75 06					jne sisic_nocumple
 000007E5  8B 1D 00000611 R					mov ebx, $SIC
 000007EB					sisic_nocumple:	
 000007EB  89 1D 00000608 R			mov $binarioSICBICLongitud, ebx

						; Incremento el BIC += $TAG
 000007F1  A1 00000615 R			mov eax, $BIC 
 000007F6  03 05 0000060D R			add eax, $TAG 
 000007FC  A3 00000615 R			mov $BIC, eax

						; Incremento el SIC += $TAG
 00000801  A1 00000611 R			mov eax, $SIC 
 00000806  03 05 0000060D R			add eax, $TAG 
 0000080C  A3 00000611 R			mov $SIC, eax

 00000811  80 3D 00000962 R			cmp $ShowMessagesMod1, 0
	   00
 00000818  74 4A				je mostrarenconsola5 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
							; Muestro el BIC si es directo el mapeo 
 0000081A  8B 15 00000113 R				mov edx, [$config]
 00000820  83 FA 00					cmp edx, 0
 00000823  75 3F					jne si4_nocumple ; edx != 1, si edx == 1 entra en si3:
 00000825						si4:
 00000825  33 DB						xor ebx, ebx ; contador ebx para binarioSICBIC

 00000827  BA 000000A8 R						mov edx, OFFSET $sBIC
 0000082C  E8 00000000 E						call WriteString

 00000831  33 C0						xor eax, eax
 00000833  3B 0D 00000615 R					cmp ecx, $BIC 
 00000839  7D 29						jge si4_nocumple ; ecx >= BIC  no entra, si es < BIC sí
 0000083B							mientras3:

 0000083B  B0 5B								mov al, '['
 0000083D  E8 00000000 E							call WriteChar
 00000842  8A 81 0000013C R							mov al, [$BloqueCache + ecx]
 00000848  88 83 00000540 R							mov [$binarioSICBIC + ebx], al ; Asigno al binario la particion del BIC
 0000084E  E8 00000000 E							call WriteChar
 00000853  B0 5D								mov al, ']'
 00000855  E8 00000000 E							call WriteChar
 0000085A  41								inc ecx
 0000085B  43								inc ebx ; contador ebx para binarioSICBIC
 0000085C  3B 0D 00000615 R					cmp ecx, $BIC
 00000862  7C D7						jl mientras3 ; ecx < BIC
 00000864						si4_nocumple:
 00000864					mostrarenconsola5:

						; Muestro el SIC si es asociativo el mapeo
 00000864  8B 15 00000113 R			mov edx, [$config]
 0000086A  83 FA 01				cmp edx, 1
 0000086D  75 5A				jne si5_nocumple ; edx != 1, si edx == 1 entra en si3:
 0000086F					si5:
 0000086F  33 DB					xor ebx, ebx ; contador ebx para binarioSICBIC

 00000871  80 3D 00000962 R				cmp $ShowMessagesMod1, 0
	   00
 00000878  74 0A					je mostrarenconsola6 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
 0000087A  BA 000000A2 R					mov edx, OFFSET $sSIC
 0000087F  E8 00000000 E					call WriteString
 00000884						mostrarenconsola6:

 00000884  33 C0					xor eax, eax
 00000886  3B 0D 00000611 R				cmp ecx, $SIC
 0000088C  7D 3B					jge si5_nocumple ; ecx >= SIC  no entra, si es < SIC sí
 0000088E						mientras4:
 0000088E  80 3D 00000962 R						cmp $ShowMessagesMod1, 0
	   00
 00000895  74 07							je mostrarenconsola7 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
 00000897  B0 5B								mov al, '['
 00000899  E8 00000000 E							call WriteChar
 0000089E								mostrarenconsola7:
 0000089E  8A 81 0000013C R							mov al, [$BloqueCache + ecx]
 000008A4  88 83 00000540 R							mov [$binarioSICBIC + ebx], al ; Asigno al binario la particion del SIC
 000008AA  80 3D 00000962 R						cmp $ShowMessagesMod1, 0
	   00
 000008B1  74 0C							je mostrarenconsola88 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones	
 000008B3  E8 00000000 E							call WriteChar
 000008B8  B0 5D								mov al, ']'
 000008BA  E8 00000000 E							call WriteChar
 000008BF								mostrarenconsola88:
 000008BF  41							inc ecx
 000008C0  43							inc ebx ; contador ebx para binarioSICBIC
 000008C1  3B 0D 00000611 R				cmp ecx, $SIC
 000008C7  7C C5					jl mientras4 ; ecx < SIC
 000008C9					si5_nocumple:

 000008C9  80 3D 00000962 R			cmp $ShowMessagesMod1, 0
	   00
 000008D0  74 05				je mostrarenconsola8 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
							; Salto de línea 
 000008D2  E8 FFFFF729					call Whiteline
 000008D7					mostrarenconsola8:
						
						; Incremento el WIB += TAG + (SIC ó BIC)
 000008D7  A1 0000033C R			mov eax, $BloqueCacheLongitud
 000008DC  A3 00000619 R			mov $WIB, eax

 000008E1  80 3D 00000962 R			cmp $ShowMessagesMod1, 0
	   00
 000008E8  74 0A				je mostrarenconsola9 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
							; Muestro el WIB 
 000008EA  BA 000000AE R				mov edx, OFFSET $sWIB
 000008EF  E8 00000000 E				call WriteString
 000008F4					mostrarenconsola9:

 000008F4  33 C0				xor eax, eax
 000008F6  3B 0D 00000619 R			cmp ecx, $WIB
 000008FC  7D 2B				jge finmodulo ; ecx >= WIB  no entra, si es < WIB sí
 000008FE					mientras5:

 000008FE  80 3D 00000962 R			cmp $ShowMessagesMod1, 0
	   00
 00000905  74 19				je mostrarenconsola10 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
 00000907  B0 5B						mov al, '['
 00000909  E8 00000000 E					call WriteChar
 0000090E  8A 81 0000013C R					mov al, [$BloqueCache + ecx]
 00000914  E8 00000000 E					call WriteChar
 00000919  B0 5D						mov al, ']'
 0000091B  E8 00000000 E					call WriteChar
 00000920					mostrarenconsola10:

 00000920  41						inc ecx
 00000921  3B 0D 00000619 R			cmp ecx, $WIB
 00000927  7E D5				jle mientras5 ; ecx <= WIB
						
 00000929					finmodulo:			
 00000929  80 3D 00000962 R			cmp $ShowMessagesMod1, 0
	   00
 00000930  74 21				je mostrarenconsola11 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
							; Salto de línea 
 00000932  E8 FFFFF6C9					call Whiteline
						
 00000937  8B 15 00000113 R				mov edx, [$config]
 0000093D  83 FA 01					cmp edx, 1
 00000940  75 07					jne si6_nocumple ; edx != 1, si edx == 1 entra en si3:
 00000942						si6:
 00000942  BA 000000D5 R					mov edx, OFFSET $sMod1Fin1
 00000947  EB 05						jmp si6_nocumplex2
 00000949						si6_nocumple:
 00000949  BA 000000B4 R					mov edx, OFFSET $sMod1Fin1_
 0000094E						si6_nocumplex2:
 0000094E  E8 00000000 E				call WriteString
 00000953					mostrarenconsola11:

 00000953  E8 FFFFFB52				call BinToInt
 00000958  8B C3				mov eax, ebx
 0000095A  A3 00000963 R			mov $Conjunto, eax ; Capturo el conjunto para usarlo en el modulo 2

 0000095F  80 3D 00000962 R			cmp $ShowMessagesMod1, 0
	   00
 00000966  74 14				je mostrarenconsola12 ; si $ShowMessagesMod1 == 0, no muestro ningun mensaje ni pido configuraciones
 00000968  E8 00000000 E				call WriteDec
 0000096D  BA 000000F9 R				mov edx, OFFSET $sMod1Fin2 
 00000972  E8 00000000 E				call WriteString

							; Solo para que no se cierre la pantalla //
 00000977  E8 00000000 E				call ReadChar 
 0000097C					mostrarenconsola12:

 0000097C  C3					ret
 0000097D				modulo1 ENDP 

					; ----------------------------
					; Módulo 2 (Menú y operaciones)
					; ----------------------------
 0000097D				modulo2 PROC 
						; Limpiar registros y variables
 0000097D  E8 FFFFFA06				call ResetMod2
 00000982					menumodulo2:
							; Limpio Pantalla
 00000982  E8 00000000 E				call ClrScr
							; Imprimo nombre del modulo
 00000987  BA 0000070E R				mov edx, OFFSET $modulo2Name
 0000098C  E8 00000000 E				call WriteString
 00000991  E8 FFFFF66A					call Whiteline 
							; Imprimo el menú
 00000996  BA 0000072E R				mov edx, OFFSET $menu2Str
 0000099B  E8 00000000 E				call WriteString
							; Solicito opción
 000009A0  33 C0					xor eax, eax
 000009A2  E8 00000000 E				call ReadDec
							; Verifico que ha elegido 
 000009A7  83 F8 01					cmp eax, 1
 000009AA  74 0E					je cache1op ; Si es 1, configuro a caché 1
 000009AC  7C D4					jl menumodulo2 ; Si es < 1, vuelvo a mostrar el menú
 000009AE  83 F8 02					cmp eax, 2
 000009B1  74 3B					je cache2op ; Si es 2, configuro a caché 2
 000009B3  83 F8 03					cmp eax, 3 
 000009B6  74 6A					je cache3op ; Si es 3, configuro a caché 3
 000009B8  7F C8					jg menumodulo2 ; Si es > 3, vuelvo a mostrar el menú 

 000009BA						cache1op:
 000009BA  C7 05 00000956 R					mov $FilasSize, 31 ; 32 
	   0000001F
 000009C4  C7 05 0000095A R					mov $ColumnasSize, 3 ; 4  
	   00000003
 000009CE  C7 05 0000095E R					mov $AnchoReal, 1 ; 8x1 matriz
	   00000001
 000009D8  C7 05 0000011B R					mov [$config + 8], 16 ; tamaño de memoria caché
	   00000010
 000009E2  C7 05 00000123 R					mov [$config + 16], 2 ; tamaño de conjuntos
	   00000002
 000009EC  EB 66						jmp empezarmodulo2

 000009EE						cache2op:
 000009EE  C7 05 00000956 R					mov $FilasSize, 31 ; 32
	   0000001F
 000009F8  C7 05 0000095A R					mov $ColumnasSize, 7 ; 8
	   00000007
 00000A02  C7 05 0000095E R					mov $AnchoReal, 2 ; 8x2  matriz
	   00000002
 00000A0C  C7 05 0000011B R					mov [$config + 8], 16 ; tamaño de memoria caché
	   00000010
 00000A16  C7 05 00000123 R					mov [$config + 16], 2 ; tamaño de conjuntos
	   00000002
 00000A20  EB 32						jmp empezarmodulo2

 00000A22						cache3op:
 00000A22  C7 05 00000956 R					mov $FilasSize, 15 ; 16
	   0000000F
 00000A2C  C7 05 0000095A R					mov $ColumnasSize, 15 ; 16
	   0000000F
 00000A36  C7 05 0000095E R					mov $AnchoReal, 4 ; 4x4 matriz
	   00000004
 00000A40  C7 05 0000011B R					mov [$config + 8], 16 ; tamaño de memoria caché
	   00000010
 00000A4A  C7 05 00000123 R					mov [$config + 16], 4 ; tamaño de conjuntos
	   00000004

 00000A54						empezarmodulo2:
 00000A54  C7 05 00000113 R					mov [$config], 1 ; mapeo asociativo
	   00000001
 00000A5E  C7 05 00000117 R					mov [$config + 4], 64 ; tamaño memoria principal
	   00000040
 00000A68  C7 05 0000011F R					mov [$config + 12], 1 ; tamaño de bloques
	   00000001

								; limpiamos la pantalla para empezar a pedir las direcciones de memoria 
 00000A72  E8 FFFFF589						call Whiteline
 00000A77  BA 000007BD R					mov edx, OFFSET $LaSimBegin
 00000A7C  E8 00000000 E					call WriteString

								; Empezamos a pedir direcciones de memoria (20 veces)
 00000A81  E8 FFFFF57A						call Whiteline 
 00000A86  E8 FFFFF575						call Whiteline
 00000A8B  C7 05 00000134 R					mov $mod2counter, 19
	   00000013
								
 00000A95							pedirdirecciones:
 00000A95  BA 000007E5 R					mov edx, OFFSET $DirStr
 00000A9A  E8 00000000 E						call WriteString
 00000A9F  E8 00000000 E						call ReadInt
									
 00000AA4  A3 0000094E R						mov $NumeroDir, eax
 00000AA9  83 F8 FF							cmp eax, -1 
 00000AAC  74 2D							je salirciclo

 00000AAE  A3 00000127 R						mov [$config + 20], eax ; Guardamos el número de la dirección
 00000AB3  C6 05 00000962 R						mov $ShowMessagesMod1, 0 ; Le decimos al modulo 1 que no muestre ni pida datos
	   00
 00000ABA  E8 FFFFFA71							call modulo1 ; LLamo al módulo uno para que procese la información 
 00000ABF  E8 FFFFF598							call ReplacementCache
 00000AC4  FE 05 00000952 R						inc $SolicitudesTotales; Incrementamos las solicitudes a caché realizadas
													
 00000ACA  FF 0D 00000134 R					dec $mod2counter
 00000AD0  8B 0D 00000134 R					mov ecx, $mod2counter
 00000AD6  83 F9 00						cmp ecx, 0
 00000AD9  7D BA						jge pedirdirecciones

 00000ADB							salirciclo:
								; Mostramos la memoria caché
 00000ADB  E8 FFFFF520						call Whiteline
 00000AE0  E8 FFFFF51B						call Whiteline
 00000AE5  E8 FFFFF73F						call ShowCache

								; Mostramos las estadísticas 
 00000AEA  E8 FFFFF511						call Whiteline 
 00000AEF  E8 FFFFF50C						call Whiteline
 00000AF4  E8 FFFFF5F6						call ShowReplacementStats
 00000AF9  C3					ret
 00000AFA				modulo2 ENDP
					
					; ----------------------------
					; Menú principal
					; ----------------------------
 00000AFA				MenuPpal PROC 
 00000AFA  33 C0				xor eax, eax

 00000AFC  83 F8 01				cmp eax, 1
 00000AFF  74 32				je si1 ; eax == 1
 00000B01  83 F8 02				cmp eax, 2
 00000B04  74 3E				je si2 ; eax == 2
 00000B06  83 F8 03				cmp eax, 3
 00000B09  74 3E				je scape ; eax == 3
 00000B0B  83 F8 04				cmp eax, 4
 00000B0E  74 39				je scape ; eax == 4

						; while: (eax < 1) || (eax > 4)
 00000B10						mientras:
 00000B10  E8 00000000 E					call ClrScr
 00000B15  BA 00000004 R					mov edx, OFFSET $menuStr
 00000B1A  E8 00000000 E					call WriteString
 00000B1F  E8 00000000 E					call ReadDec
 00000B24  83 F8 01					cmp eax, 1
 00000B27  7C E7					jl mientras
 00000B29  83 F8 04					cmp eax, 4
 00000B2C  7F E2					jg mientras
						
						; Arrancamos el módulo 1 
 00000B2E  83 F8 01				cmp eax, 1
 00000B31  75 0C				jne si1_nocumple ; eax != 1 salta, si eax == 1 entra en si1
 00000B33					si1:
 00000B33  C6 05 00000962 R				mov $ShowMessagesMod1, 1
	   01
 00000B3A  E8 FFFFF9F1					call modulo1
 00000B3F					si1_nocumple:

						; Arrancamos el módulo 2 
 00000B3F  83 F8 02				cmp eax, 2
 00000B42  75 05				jne scape ; eax != 2 salta, si eax == 2 entra en si2
 00000B44					si2:
 00000B44  E8 FFFFFE34					call modulo2

 00000B49					scape:
 00000B49  C3						ret
 00000B4A				MenuPpal ENDP	

					; ----------------------------
					; void Main()
					; ----------------------------
 00000B4A				main PROC 
 00000B4A					siguiente: 	
 00000B4A  E8 00000000 E				call ClrScr
 00000B4F  E8 FFFFFFA6					call MenuPpal

 00000B54					seguir:  
 00000B54  E8 FFFFF4A7					call Whiteline
 00000B59  E8 FFFFF4A2					call Whiteline
 00000B5E  BA 00000072 R				mov edx, OFFSET $menuRegreso
 00000B63  E8 00000000 E				call WriteString
 00000B68  E8 00000000 E				call ReadDec
 00000B6D  83 F8 01					cmp eax,1 
 00000B70  74 D8					je siguiente
 00000B72  83 F8 02					cmp eax,2
 00000B75  74 04					je Fin
 00000B77  7F DB					jg seguir
 00000B79  7C D9					jl seguir 
						
 00000B7B					Fin:	
							exit
 00000B7B  6A 00	   *	    push   +000000000h
 00000B7D  E8 00000000 E   *	    call   ExitProcess
 00000B82			   	main ENDP
				END main
Microsoft (R) Macro Assembler Version 12.00.31101.0	    01/27/17 16:49:24
main.asm						     Symbols 2 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000967 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000B82 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

Base2  . . . . . . . . . . . . .	P Near	 0000044F _TEXT	Length= 00000037 Public STDCALL
  si_es_cero . . . . . . . . . .	L Near	 0000045B _TEXT	
  si_es_uno  . . . . . . . . . .	L Near	 00000462 _TEXT	
  si_mayor_uno . . . . . . . . .	L Near	 00000469 _TEXT	
  mientras . . . . . . . . . . .	L Near	 00000470 _TEXT	
  scape  . . . . . . . . . . . .	L Near	 00000485 _TEXT	
BinToInt . . . . . . . . . . . .	P Near	 000004AA _TEXT	Length= 00000030 Public STDCALL
  ciclo  . . . . . . . . . . . .	L Near	 000004B6 _TEXT	
  scape  . . . . . . . . . . . .	L Near	 000004D0 _TEXT	
  fin  . . . . . . . . . . . . .	L Near	 000004D9 _TEXT	
CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Division . . . . . . . . . . . .	P Near	 00000419 _TEXT	Length= 00000036 Public STDCALL
  mientras . . . . . . . . . . .	L Near	 0000042A _TEXT	
  es_cero  . . . . . . . . . . .	L Near	 0000043B _TEXT	
  es_uno . . . . . . . . . . . .	L Near	 00000442 _TEXT	
  fin  . . . . . . . . . . . . .	L Near	 00000449 _TEXT	
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FifoReplacement  . . . . . . . .	P Near	 0000000B _TEXT	Length= 00000051 Public STDCALL
  lleno  . . . . . . . . . . . .	L Near	 0000001C _TEXT	
  nolleno  . . . . . . . . . . .	L Near	 0000002E _TEXT	
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetExponent  . . . . . . . . . .	P Near	 000004FB _TEXT	Length= 00000035 Public STDCALL
  mientras . . . . . . . . . . .	L Near	 00000513 _TEXT	
  scape  . . . . . . . . . . . .	L Near	 00000528 _TEXT	
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IntToBin . . . . . . . . . . . .	P Near	 00000486 _TEXT	Length= 00000024 Public STDCALL
  mientras . . . . . . . . . . .	L Near	 0000048D _TEXT	
  incremento . . . . . . . . . .	L Near	 000004A3 _TEXT	
  scape  . . . . . . . . . . . .	L Near	 000004A9 _TEXT	
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MenuPpal . . . . . . . . . . . .	P Near	 00000AFA _TEXT	Length= 00000050 Public STDCALL
  mientras . . . . . . . . . . .	L Near	 00000B10 _TEXT	
  si1  . . . . . . . . . . . . .	L Near	 00000B33 _TEXT	
  si1_nocumple . . . . . . . . .	L Near	 00000B3F _TEXT	
  si2  . . . . . . . . . . . . .	L Near	 00000B44 _TEXT	
  scape  . . . . . . . . . . . .	L Near	 00000B49 _TEXT	
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Raise  . . . . . . . . . . . . .	P Near	 000003DE _TEXT	Length= 0000003B Public STDCALL
  mientras . . . . . . . . . . .	L Near	 000003F0 _TEXT	
  es_cero_d  . . . . . . . . . .	L Near	 00000403 _TEXT	
  es_cero  . . . . . . . . . . .	L Near	 0000040A _TEXT	
  es_uno . . . . . . . . . . . .	L Near	 00000411 _TEXT	
  fin  . . . . . . . . . . . . .	L Near	 00000418 _TEXT	
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReplacementCache . . . . . . . .	P Near	 0000005C _TEXT	Length= 00000093 Public STDCALL
  columna  . . . . . . . . . . .	L Near	 0000007D _TEXT	
  fifo_  . . . . . . . . . . . .	L Near	 0000009C _TEXT	
  forzosa  . . . . . . . . . . .	L Near	 000000A3 _TEXT	
  nofifo . . . . . . . . . . . .	L Near	 000000B6 _TEXT	
  acierto  . . . . . . . . . . .	L Near	 000000D9 _TEXT	
  salir  . . . . . . . . . . . .	L Near	 000000EE _TEXT	
ResetBinDec  . . . . . . . . . .	P Near	 000002E4 _TEXT	Length= 00000020 Public STDCALL
  ciclo  . . . . . . . . . . . .	L Near	 000002F3 _TEXT	
ResetBin . . . . . . . . . . . .	P Near	 000002C7 _TEXT	Length= 0000001D Public STDCALL
  ciclo  . . . . . . . . . . . .	L Near	 000002D3 _TEXT	
ResetBloqueCache . . . . . . . .	P Near	 00000304 _TEXT	Length= 00000020 Public STDCALL
  ciclo  . . . . . . . . . . . .	L Near	 00000313 _TEXT	
ResetCache . . . . . . . . . . .	P Near	 00000324 _TEXT	Length= 00000016 Public STDCALL
  limpiar  . . . . . . . . . . .	L Near	 00000329 _TEXT	
ResetFifoPointer . . . . . . . .	P Near	 0000033A _TEXT	Length= 00000016 Public STDCALL
  limpiar  . . . . . . . . . . .	L Near	 0000033F _TEXT	
ResetMod1  . . . . . . . . . . .	P Near	 00000350 _TEXT	Length= 00000038 Public STDCALL
ResetMod2  . . . . . . . . . . .	P Near	 00000388 _TEXT	Length= 00000056 Public STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowCache  . . . . . . . . . . .	P Near	 00000229 _TEXT	Length= 0000009E Public STDCALL
  filas  . . . . . . . . . . . .	L Near	 00000235 _TEXT	
  columnas . . . . . . . . . . .	L Near	 0000025C _TEXT	
  novacio  . . . . . . . . . . .	L Near	 0000028A _TEXT	
  vacio  . . . . . . . . . . . .	L Near	 00000291 _TEXT	
  cerrarparentesis . . . . . . .	L Near	 00000298 _TEXT	
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowReplacementStats . . . . . .	P Near	 000000EF _TEXT	Length= 0000013A Public STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnitConversor  . . . . . . . . .	P Near	 000004DA _TEXT	Length= 00000021 Public STDCALL
  si1  . . . . . . . . . . . . .	L Near	 000004E4 _TEXT	
  si2  . . . . . . . . . . . . .	L Near	 000004EC _TEXT	
  scape  . . . . . . . . . . . .	L Near	 000004FA _TEXT	
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Whiteline  . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000000B Public STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000B4A _TEXT	Length= 00000038 Public STDCALL
  siguiente  . . . . . . . . . .	L Near	 00000B4A _TEXT	
  seguir . . . . . . . . . . . .	L Near	 00000B54 _TEXT	
  Fin  . . . . . . . . . . . . .	L Near	 00000B7B _TEXT	
modulo1  . . . . . . . . . . . .	P Near	 00000530 _TEXT	Length= 0000044D Public STDCALL
  si1  . . . . . . . . . . . . .	L Near	 00000636 _TEXT	
  si1_nocumple . . . . . . . . .	L Near	 0000064F _TEXT	
  mostrarenconsola . . . . . . .	L Near	 00000663 _TEXT	
  si2  . . . . . . . . . . . . .	L Near	 0000067A _TEXT	
  si2_nocumple . . . . . . . . .	L Near	 000006C0 _TEXT	
  si3  . . . . . . . . . . . . .	L Near	 000006CB _TEXT	
  si3_nocumple . . . . . . . . .	L Near	 0000072C _TEXT	
  mientras1  . . . . . . . . . .	L Near	 00000755 _TEXT	
  finmientras1 . . . . . . . . .	L Near	 00000772 _TEXT	
  mostrarenconsola2  . . . . . .	L Near	 0000078A _TEXT	
  mientras2  . . . . . . . . . .	L Near	 00000796 _TEXT	
  mostrarenconsola3  . . . . . .	L Near	 000007B8 _TEXT	
  finmientras2 . . . . . . . . .	L Near	 000007C1 _TEXT	
  mostrarenconsola4  . . . . . .	L Near	 000007CF _TEXT	
  sibic_nocumple . . . . . . . .	L Near	 000007E0 _TEXT	
  sisic_nocumple . . . . . . . .	L Near	 000007EB _TEXT	
  si4  . . . . . . . . . . . . .	L Near	 00000825 _TEXT	
  mientras3  . . . . . . . . . .	L Near	 0000083B _TEXT	
  si4_nocumple . . . . . . . . .	L Near	 00000864 _TEXT	
  mostrarenconsola5  . . . . . .	L Near	 00000864 _TEXT	
  si5  . . . . . . . . . . . . .	L Near	 0000086F _TEXT	
  mostrarenconsola6  . . . . . .	L Near	 00000884 _TEXT	
  mientras4  . . . . . . . . . .	L Near	 0000088E _TEXT	
  mostrarenconsola7  . . . . . .	L Near	 0000089E _TEXT	
  mostrarenconsola88 . . . . . .	L Near	 000008BF _TEXT	
  si5_nocumple . . . . . . . . .	L Near	 000008C9 _TEXT	
  mostrarenconsola8  . . . . . .	L Near	 000008D7 _TEXT	
  mostrarenconsola9  . . . . . .	L Near	 000008F4 _TEXT	
  mientras5  . . . . . . . . . .	L Near	 000008FE _TEXT	
  mostrarenconsola10 . . . . . .	L Near	 00000920 _TEXT	
  finmodulo  . . . . . . . . . .	L Near	 00000929 _TEXT	
  si6  . . . . . . . . . . . . .	L Near	 00000942 _TEXT	
  si6_nocumple . . . . . . . . .	L Near	 00000949 _TEXT	
  si6_nocumplex2 . . . . . . . .	L Near	 0000094E _TEXT	
  mostrarenconsola11 . . . . . .	L Near	 00000953 _TEXT	
  mostrarenconsola12 . . . . . .	L Near	 0000097C _TEXT	
modulo2  . . . . . . . . . . . .	P Near	 0000097D _TEXT	Length= 0000017D Public STDCALL
  menumodulo2  . . . . . . . . .	L Near	 00000982 _TEXT	
  cache1op . . . . . . . . . . .	L Near	 000009BA _TEXT	
  cache2op . . . . . . . . . . .	L Near	 000009EE _TEXT	
  cache3op . . . . . . . . . . .	L Near	 00000A22 _TEXT	
  empezarmodulo2 . . . . . . . .	L Near	 00000A54 _TEXT	
  pedirdirecciones . . . . . . .	L Near	 00000A95 _TEXT	
  salirciclo . . . . . . . . . .	L Near	 00000ADB _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

$AciertosCount . . . . . . . . .	Byte	 00000953 _DATA	
$AnchoReal . . . . . . . . . . .	DWord	 0000095E _DATA	
$BIC . . . . . . . . . . . . . .	DWord	 00000615 _DATA	
$BloqueCacheLongitud . . . . . .	DWord	 0000033C _DATA	
$BloqueCache . . . . . . . . . .	Byte	 0000013C _DATA	
$Cache . . . . . . . . . . . . .	DWord	 000008C6 _DATA	
$ColumnasSize  . . . . . . . . .	DWord	 0000095A _DATA	
$Conjunto  . . . . . . . . . . .	DWord	 00000963 _DATA	
$DWnumero  . . . . . . . . . . .	DWord	 00000138 _DATA	
$DirStr  . . . . . . . . . . . .	Byte	 000007E5 _DATA	
$FallaConflictoCount . . . . . .	Byte	 00000955 _DATA	
$FallaForzosaCount . . . . . . .	Byte	 00000954 _DATA	
$FifoPointer . . . . . . . . . .	DWord	 0000090A _DATA	
$FilasSize . . . . . . . . . . .	DWord	 00000956 _DATA	
$LaSimBegin  . . . . . . . . . .	Byte	 000007BD _DATA	
$NumeroDir . . . . . . . . . . .	DWord	 0000094E _DATA	
$SIC . . . . . . . . . . . . . .	DWord	 00000611 _DATA	
$ShowMessagesMod1  . . . . . . .	Byte	 00000962 _DATA	
$SolicitudesTotales  . . . . . .	Byte	 00000952 _DATA	
$TAG . . . . . . . . . . . . . .	DWord	 0000060D _DATA	
$WIB . . . . . . . . . . . . . .	DWord	 00000619 _DATA	
$binarioLongitud . . . . . . . .	Byte	 0000060C _DATA	
$binarioSICBICLongitud . . . . .	DWord	 00000608 _DATA	
$binarioSICBIC . . . . . . . . .	Byte	 00000540 _DATA	
$binario . . . . . . . . . . . .	Byte	 00000340 _DATA	
$br_str  . . . . . . . . . . . .	Byte	 00000000 _DATA	
$config  . . . . . . . . . . . .	DWord	 00000113 _DATA	
$contador  . . . . . . . . . . .	Byte	 0000012F _DATA	
$divcounter  . . . . . . . . . .	DWord	 00000130 _DATA	
$huboAcierto . . . . . . . . . .	Byte	 000008BD _DATA	
$huboFallaConflicto  . . . . . .	Byte	 000008A7 _DATA	
$huboFallaForzosa  . . . . . . .	Byte	 00000898 _DATA	
$menu2Str  . . . . . . . . . . .	Byte	 0000072E _DATA	
$menuRegreso . . . . . . . . . .	Byte	 00000072 _DATA	
$menuStr . . . . . . . . . . . .	Byte	 00000004 _DATA	
$mod2counter . . . . . . . . . .	DWord	 00000134 _DATA	
$modulo1Name . . . . . . . . . .	Byte	 0000061D _DATA	
$modulo2Name . . . . . . . . . .	Byte	 0000070E _DATA	
$n1024 . . . . . . . . . . . . .	DWord	 0000010F _DATA	
$sBIC  . . . . . . . . . . . . .	Byte	 000000A8 _DATA	
$sMod1Fin1_  . . . . . . . . . .	Byte	 000000B4 _DATA	
$sMod1Fin1 . . . . . . . . . . .	Byte	 000000D5 _DATA	
$sMod1Fin2 . . . . . . . . . . .	Byte	 000000F9 _DATA	
$sSIC  . . . . . . . . . . . . .	Byte	 000000A2 _DATA	
$sTAG  . . . . . . . . . . . . .	Byte	 0000009C _DATA	
$sWIB  . . . . . . . . . . . . .	Byte	 000000AE _DATA	
$selectBloqStr . . . . . . . . .	Byte	 000006D3 _DATA	
$selectConjStr . . . . . . . . .	Byte	 000006E9 _DATA	
$selectDirStr  . . . . . . . . .	Byte	 00000701 _DATA	
$selectMapeoStr  . . . . . . . .	Byte	 00000649 _DATA	
$selectMemCStr . . . . . . . . .	Byte	 000006B7 _DATA	
$selectMemPStr . . . . . . . . .	Byte	 00000697 _DATA	
$selectUnitStr . . . . . . . . .	Byte	 00000677 _DATA	
$statsAciertos . . . . . . . . .	Byte	 00000876 _DATA	
$statsFallasConf . . . . . . . .	Byte	 00000848 _DATA	
$statsFallasForz . . . . . . . .	Byte	 00000833 _DATA	
$statsFallas . . . . . . . . . .	Byte	 00000820 _DATA	
$statsTasaAciertos . . . . . . .	Byte	 00000883 _DATA	
$statsTasaFallas . . . . . . . .	Byte	 00000862 _DATA	
$statsTotal  . . . . . . . . . .	Byte	 000007F1 _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
BufSize  . . . . . . . . . . . .	Number	 00000050h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
cyan . . . . . . . . . . . . . .	Number	 00000003h   
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
red  . . . . . . . . . . . . . .	Number	 00000004h   
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
